# Water Vending Maintenance Bot - Fix Plan
# Date: September 2, 2025

## üéØ EXECUTIVE SUMMARY

**Two critical issues need fixing: data handling AND scheduler architecture. Both are separate problems that must be resolved.**

### Problem 1: Data Format Handling
- API returns malformed values like "13254.000.00" 
- Database insertion fails silently
- Collection data fetched but not saved

### Problem 2: Scheduler Architecture
- JavaScript timers die with process restarts
- Schedulers depend on bot availability
- No 8 AM notifications, silent failures

## üîç PROBLEM ANALYSIS

### Issues Identified
1. **Data Format Errors**: API returns malformed numeric values causing database failures
2. **Scheduler Architecture**: JavaScript timers die with process restarts, no persistence
3. **Bot Dependency**: Schedulers fail when bot is unavailable

### Root Causes
- No data validation/cleaning before database insertion
- Schedulers use `setTimeout` (in-memory only, die with restarts)
- Schedulers depend on `global.bot` availability
- No health checks or auto-recovery

### Evidence from Logs
- Multiple scheduler restarts: Aug 27, 31, Sep 1, 2
- `[WARN] Bot not available for summary`
- Collection works but notifications fail silently

## üõ†Ô∏è IMMEDIATE FIXES (Priority 1)

### 1. Replace JavaScript Timers with Cron Jobs (CRITICAL)
**Why**: Cron jobs survive process restarts, JavaScript timers don't

**Implementation**:
```bash
# Daily collection at 8 AM Kyiv time (5 AM UTC)
0 5 * * * cd /path/to/bot && node schedulers/collection-fetcher.js

# Daily summary at 8 AM Kyiv time (5 AM UTC)  
0 5 * * * cd /path/to/bot && node schedulers/summary-runner.js
```

**Benefits**: Survives restarts, independent of bot, system-level reliability

### 2. Fix Data Parsing
**File**: `schedulers/collection-fetcher.js`

```javascript
const cleanNumericValue = (value) => {
    if (!value) return 0;
    let cleaned = value.toString().trim();
    
    // Remove extra dots (e.g., "13254.000.00" -> "13254.00")
    const parts = cleaned.split('.');
    if (parts.length > 2) {
        cleaned = parts[0] + '.' + parts[parts.length - 1];
    }
    
    const parsed = parseFloat(cleaned);
    return isNaN(parsed) ? 0 : parsed;
};
```

### 3. Add Data Validation
**File**: `database/repositories/collection-repository.js`

```javascript
validateNumericData(data) {
    if (typeof data.sum_banknotes !== 'number' || isNaN(data.sum_banknotes)) {
        throw new Error(`Invalid banknotes value: ${data.sum_banknotes}`);
    }
    if (typeof data.sum_coins !== 'number' || isNaN(data.sum_coins)) {
        throw new Error(`Invalid coins value: ${data.sum_coins}`);
    }
}
```

### 4. Implement Scheduler Health Checks
**File**: `schedulers/scheduler.js`
**Action**: Add heartbeat system and auto-recovery for failed schedulers

## üîÑ IMPROVEMENTS (Priority 2)

### 5. Decouple Schedulers from Bot Process
**Why**: Bot restarts shouldn't break collection and summary tasks
**Implementation**: Use direct database operations or separate notification service

### 6. Enhanced Error Handling with Retry Logic
```javascript
const saveWithRetry = async (data, maxRetries = 3) => {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return await collectionRepo.saveCollectionData(data);
        } catch (error) {
            if (attempt === maxRetries) throw error;
            logger.warn(`Retry ${attempt}/${maxRetries} for device ${data.device_id}`);
            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
    }
};
```

### 7. Data Quality Monitoring
**File**: `schedulers/data-processor.js`
**Action**: Log and track data quality issues

### 8. Failed Data Recovery
**File**: `schedulers/collection-fetcher.js`
**Action**: Store failed entries for manual review

## üìä MONITORING & ALERTS (Priority 3)

### 9. Collection Success Metrics
**File**: `schedulers/collection-fetcher.js`
**Action**: Track success/failure rates and data quality issues

### 10. Enhanced Admin Notifications
**File**: `schedulers/scheduler.js`
**Action**: Better error reporting with details

## üß™ TESTING STRATEGY

### 11. Test Data Cleaning
- Create test cases with malformed values
- Verify cleaning function handles edge cases
- Test database insertion with cleaned data

### 12. Integration Testing
- Test full collection flow with problematic data
- Verify error handling and retry logic
- Test admin notifications

## üìã IMPLEMENTATION ORDER

1. **IMMEDIATE (Today)**: Replace JavaScript timers with cron jobs
2. **Week 1**: Implement data cleaning and validation
3. **Week 2**: Decouple schedulers from bot process
4. **Week 3**: Implement monitoring and alerts
5. **Week 4**: Testing and validation

## üéØ SUCCESS CRITERIA

- [ ] All malformed numeric values properly cleaned
- [ ] Collection data successfully saved to database
- [ ] Failed entries logged and recoverable
- [ ] Admin receives detailed collection reports
- [ ] Data quality issues tracked and reported
- [ ] System handles API inconsistencies gracefully

## üîç LONG-TERM CONSIDERATIONS

### API Data Quality
- Monitor frequency of malformed data
- Report issues to water vending service
- Consider data quality agreements

### System Resilience
- Implement circuit breaker pattern for API failures
- Add health checks for collection process
- Consider backup data sources

### Performance Optimization
- Batch database operations
- Implement connection pooling optimization
- Add caching for frequently accessed data

---
**Created**: September 2, 2025
**Status**: Planning Phase
**Next Action**: Create cron jobs to replace JavaScript timers for reliable scheduling
