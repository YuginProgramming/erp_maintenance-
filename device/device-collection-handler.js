import axios from "axios";
import { logger } from "../logger/index.js";

// Function to extract collector information from description
const extractCollectorInfo = (descr) => {
    if (!descr) return { id: null, nik: null };
    
    // Try to decode the description (it might be encoded)
    let decodedDescr = descr;
    try {
        decodedDescr = decodeURIComponent(descr);
    } catch (e) {
        decodedDescr = descr;
    }
    
    // Handle specific encoding issues
    if (decodedDescr === '–†‚Ä†–†—ñ–†—ï–°–Ç' || decodedDescr.includes('–†‚Ä†–†—ñ–†—ï–°–Ç')) {
        return {
            id: 'Kirk',
            nik: 'Kirk'
        };
    }
    
    // Handle –†"–†—ò–†—ë–°‚Äö–°–Ç–†—ï encoding issue
    if (decodedDescr === '–†"–†—ò–†—ë–°‚Äö–°–Ç–†—ï' || decodedDescr.includes('–†"–†—ò–†—ë–°‚Äö–°–Ç–†—ï')) {
        return {
            id: 'Anna',
            nik: 'Anna'
        };
    }
    
    // Handle –Ü–≥–æ—Ä - leave as is (proper Ukrainian text)
    if (decodedDescr === '–Ü–≥–æ—Ä' || decodedDescr.includes('–Ü–≥–æ—Ä')) {
        return {
            id: '–Ü–≥–æ—Ä',
            nik: '–Ü–≥–æ—Ä'
        };
    }
    
    // Extract collector info - format seems to be "Name - "
    const match = decodedDescr.match(/^(.+?)\s*-\s*$/);
    if (match) {
        const collectorName = match[1].trim();
        return {
            id: null,
            nik: collectorName
        };
    }
    
    return {
        id: null,
        nik: decodedDescr.trim() || null
    };
};

// Function to fetch device collection data from database
const fetchDeviceCollection = async (device_id, startDate, endDate) => {
    try {
        const { sequelize, ensureConnection } = await import('../database/sequelize.js');
        const { Collection } = await import('../database/maintenance-models.js');
        const { Op } = await import('sequelize');
        
        await ensureConnection();
        
        logger.info(`Fetching collection data for device ${device_id} from ${startDate} to ${endDate}`);
        
        // Get device info (first record to get machine name)
        const deviceInfo = await Collection.findOne({
            where: { device_id: device_id },
            attributes: ['machine'],
            raw: true
        });
        
        // Get collection data
        const collections = await Collection.findAll({
            where: {
                device_id: device_id,
                date: {
                    [Op.between]: [startDate, endDate]
                }
            },
            order: [['date', 'DESC'], ['id', 'DESC']],
            raw: true
        });
        
        // Format data to match API response structure
        const formattedData = collections.map(collection => ({
            id: collection.id,
            date: collection.date,
            sum_banknotes: collection.sum_banknotes,
            sum_coins: collection.sum_coins,
            total_sum: collection.total_sum,
            note: collection.note,
            collector_id: collection.collector_id,
            collector_nik: collection.collector_nik
        }));
        
        return {
            status: 'success',
            device_id: device_id,
            address: deviceInfo?.machine || '–ù–µ –≤–∫–∞–∑–∞–Ω–æ',
            data: formattedData
        };
        
    } catch (error) {
        logger.error(`Error fetching collection data for device ${device_id}: ${error.message}`);
        return { error: error.message };
    }
};

// Function to format collection data for Telegram message
const formatCollectionData = (collectionData) => {
    if (!collectionData || collectionData.error) {
        return `‚ùå **–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö —ñ–Ω–∫–∞—Å–∞—Ü—ñ—ó**\n\n${collectionData?.error || '–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞'}`;
    }

    const { device_id, address, data } = collectionData;
    
    if (!data || data.length === 0) {
        return `üìä **–ó–≤—ñ—Ç –∑ —ñ–Ω–∫–∞—Å–∞—Ü—ñ—ó –∞–ø–∞—Ä–∞—Ç—É**\n\n` +
               `ID –∞–ø–∞—Ä–∞—Ç—É: ${device_id}\n` +
               `–ê–¥—Ä–µ—Å–∞: ${address || '–ù–µ –≤–∫–∞–∑–∞–Ω–æ'}\n\n` +
               `–î–∞–Ω—ñ —ñ–Ω–∫–∞—Å–∞—Ü—ñ—ó –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–π –ø–µ—Ä—ñ–æ–¥ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ`;
    }

    let message = `üìä **–ó–≤—ñ—Ç –∑ —ñ–Ω–∫–∞—Å–∞—Ü—ñ—ó –∞–ø–∞—Ä–∞—Ç—É**\n\n` +
                  `ID –∞–ø–∞—Ä–∞—Ç—É: ${device_id}\n` +
                  `–ê–¥—Ä–µ—Å–∞: ${address || '–ù–µ –≤–∫–∞–∑–∞–Ω–æ'}\n` +
                  `–ü–µ—Ä—ñ–æ–¥: ${data.length} –∑–∞–ø–∏—Å—ñ–≤ —ñ–Ω–∫–∞—Å–∞—Ü—ñ—ó\n\n`;

    // Calculate totals
    let totalSum = 0;
    let totalBanknotes = 0;
    let totalCoins = 0;

    data.forEach(entry => {
        totalSum += parseFloat(entry.total_sum) || 0;
        totalBanknotes += parseFloat(entry.sum_banknotes) || 0;
        totalCoins += parseFloat(entry.sum_coins) || 0;
    });

    message += `**–ü—ñ–¥—Å—É–º–æ–∫:**\n` +
               `–ó–∞–≥–∞–ª—å–Ω–∞ —Å—É–º–∞: ${totalSum.toFixed(2)} –≥—Ä–Ω\n` +
               `–ö—É–ø—é—Ä–∏: ${totalBanknotes.toFixed(2)} –≥—Ä–Ω\n` +
               `–ú–æ–Ω–µ—Ç–∏: ${totalCoins.toFixed(2)} –≥—Ä–Ω\n\n`;

    return message;
};

// Function to format individual collection entry
const formatCollectionEntry = (entry, index) => {
    const date = new Date(entry.date).toLocaleDateString('uk-UA');
    const sum = parseFloat(entry.total_sum) || 0;
    const banknotes = parseFloat(entry.sum_banknotes) || 0;
    const coins = parseFloat(entry.sum_coins) || 0;
    
    let message = `üìÖ **–ó–∞–ø–∏—Å —ñ–Ω–∫–∞—Å–∞—Ü—ñ—ó #${index + 1}**\n` +
                  `–î–∞—Ç–∞: ${date}\n` +
                  `ID –∫–∞—Ä—Ç–∏: ${entry.card_id || '–ù/–î'}\n` +
                  `–°—É–º–∞: ${sum.toFixed(2)} –≥—Ä–Ω\n` +
                  `–ö—É–ø—é—Ä–∏: ${banknotes.toFixed(2)} –≥—Ä–Ω\n` +
                  `–ú–æ–Ω–µ—Ç–∏: ${coins.toFixed(2)} –≥—Ä–Ω\n`;
    
    if (entry.collector_nik) {
        message += `–Ü–Ω–∫–∞—Å–∞—Ç–æ—Ä: ${entry.collector_nik}\n`;
    }
    
    if (entry.note) {
        message += `–û–ø–∏—Å: ${entry.note}\n`;
    }
    
    return message;
};

// Main function to send device collection data to Telegram
const sendDeviceCollectionToTelegram = async (bot, chatId, device_id, startDate, endDate) => {
    try {
        // Validate date format
        if (!validateDateFormat(startDate) || !validateDateFormat(endDate)) {
            await bot.sendMessage(chatId, '‚ùå **–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç–∏**\n\n–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç YYYY-MM-DD (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 2025-06-01)');
            return;
        }

        // Validate date range
        const start = new Date(startDate);
        const end = new Date(endDate);
        if (start > end) {
            await bot.sendMessage(chatId, '‚ùå **–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π –¥—ñ–∞–ø–∞–∑–æ–Ω –¥–∞—Ç**\n\n–î–∞—Ç–∞ –ø–æ—á–∞—Ç–∫—É –ø–æ–≤–∏–Ω–Ω–∞ –±—É—Ç–∏ —Ä–∞–Ω—ñ—à–µ –¥–∞—Ç–∏ –∫—ñ–Ω—Ü—è');
            return;
        }

        // Send loading message
        const loadingMsg = await bot.sendMessage(chatId, `üìä –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö —ñ–Ω–∫–∞—Å–∞—Ü—ñ—ó –¥–ª—è –∞–ø–∞—Ä–∞—Ç—É ${device_id}...`);

        // Fetch collection data from API
        const collectionData = await fetchDeviceCollection(device_id, startDate, endDate);
        
        if (collectionData.error) {
            await bot.editMessageText(`‚ùå **–ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö —ñ–Ω–∫–∞—Å–∞—Ü—ñ—ó**\n\n${collectionData.error}`, {
                chat_id: chatId,
                message_id: loadingMsg.message_id,
                parse_mode: 'Markdown'
            });
            return;
        }

        // Send summary first
        const summaryMessage = formatCollectionData(collectionData);
        await bot.editMessageText(summaryMessage, {
            chat_id: chatId,
            message_id: loadingMsg.message_id,
            parse_mode: 'Markdown'
        });

        // If there's collection data, send individual entries
        if (collectionData.data && collectionData.data.length > 0) {
            const MAX_ENTRIES_TO_SEND = 10; // Limit to prevent spam
            const entriesToSend = collectionData.data.slice(0, MAX_ENTRIES_TO_SEND);
            const hasMoreEntries = collectionData.data.length > MAX_ENTRIES_TO_SEND;

            // Send each collection entry as a separate message
            for (let i = 0; i < entriesToSend.length; i++) {
                const entry = entriesToSend[i];
                const entryMessage = formatCollectionEntry(entry, i);
                
                try {
                    await bot.sendMessage(chatId, entryMessage, { parse_mode: 'Markdown' });
                    
                    // Small delay to avoid rate limiting
                    if (i < entriesToSend.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                } catch (entryError) {
                    logger.error(`Error sending collection entry ${i} to chat ${chatId}: ${entryError.message}`);
                }
            }

            // Send completion message if there are more entries
            if (hasMoreEntries) {
                const remainingCount = collectionData.data.length - MAX_ENTRIES_TO_SEND;
                const completionMessage = `üìã **–ü—Ä–∏–º—ñ—Ç–∫–∞:** –©–µ ${remainingCount} –∑–∞–ø–∏—Å—ñ–≤ —ñ–Ω–∫–∞—Å–∞—Ü—ñ—ó –¥–æ—Å—Ç—É–ø–Ω–æ. –ü–æ–∫–∞–∑–∞–Ω–æ –ø–µ—Ä—à—ñ ${MAX_ENTRIES_TO_SEND} —â–æ–± —É–Ω–∏–∫–Ω—É—Ç–∏ —Å–ø–∞–º—É.`;
                await bot.sendMessage(chatId, completionMessage, { parse_mode: 'Markdown' });
            }
        }

        logger.info(`Collection data sent to chat ${chatId} for device ${device_id}. Found ${collectionData.data?.length || 0} entries.`);

            } catch (error) {
            logger.error(`Error sending collection data to chat ${chatId}: ${error.message}`);
            
            try {
                await bot.sendMessage(chatId, '‚ùå –ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö —ñ–Ω–∫–∞—Å–∞—Ü—ñ—ó. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑ –ø—ñ–∑–Ω—ñ—à–µ.');
            } catch (sendError) {
                logger.error(`Failed to send error message to chat ${chatId}: ${sendError.message}`);
            }
        }
};

// Function to get collection data as JSON (for other uses)
const getDeviceCollection = async (device_id, startDate, endDate) => {
    return await fetchDeviceCollection(device_id, startDate, endDate);
};

// Helper function to validate date format
const validateDateFormat = (dateString) => {
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateRegex.test(dateString)) {
        return false;
    }
    
    const date = new Date(dateString);
    return !isNaN(date.getTime());
};

// Helper function to get default date range (last 7 days)
const getDefaultDateRange = () => {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(endDate.getDate() - 7);
    
    return {
        startDate: startDate.toISOString().split('T')[0], // YYYY-MM-DD
        endDate: endDate.toISOString().split('T')[0]      // YYYY-MM-DD
    };
};

export {
    fetchDeviceCollection,
    formatCollectionData,
    formatCollectionEntry,
    sendDeviceCollectionToTelegram,
    getDeviceCollection,
    validateDateFormat,
    getDefaultDateRange
};
